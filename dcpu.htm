<html>
<head>
  <title>DCPU-16 emulator</title>
  <script type="text/javascript" src="js/assembler.js?v=1"></script>
  <script type="text/javascript" src="js/disassembler.js?v=1"></script>
  <script type="text/javascript" src="js/dcpu.js?v=1"></script>
  <script type="text/javascript" src="js/screen.js?v=1"></script>
  <style>
    body, button {
      font-family: Verdana, Tahoma, sans-serif;
      font-size: 14px;
    }
    button.big {
      font-size: 20px;
      width: 160px;
      height: 40px;
      text-align: left;
      margin: 4px;
    }
    .filewrap {
      margin: 6px 6px 0px 0px;
      position: relative;
      display: inline-block;
    }
    .filewrap .file {
      position: absolute;
      opacity: 0;
      -moz-opacity: 0;
      filter:alpha(opacity=0);
      margin: 0;
      width: 100%;
      height: 100%;
      z-index: -100;
    }

    h3 {
      font-size: 22px;
      margin-bottom: 0px;
    }
    table td {
      position: relative;
    }
    .editor, .editor td {
      font-family: Monaco, Lucida Console, Andale Mono, Courier New, Courier, monospace;
      font-size: 14px;
      line-height: 19px;
      margin: 0;
    }
    #linenums {
      padding: 2px 0px 2px 0px;
      text-align: right;
      color: gray;
    }
    #linenums u {
      margin: 1px 1px 2px 1px;
      padding: 1px 11px;
      line-height: 15px;
      text-decoration: none;
      display: block;
      cursor: pointer;
    }
    #linenums u.breakpoint {
      padding: 0px 10px;
      background-color: #adf;
      border: 1px solid #3ab;
      border-radius: 3px;
    }
    #offsets {
      padding: 4px 10px 2px 24px;
      color: gray;
    }
    #da_lines {
      padding: 4px 10px 2px 24px;
      color: gray;
    }
    #code {
      width: 100%;
      min-width: 500px;
      background-color: transparent;
    }
    #da_input {
      width: 100%;
      min-width: 200px;
    }
    #dump {
      overflow-x: auto;
      overflow-y: visible;
      white-space: nowrap;
      padding: 4px;
      width: 300px;
    }
    #da_code {
      padding: 4px;
    }
    #log {
      padding-top: 6px;
    }
    #log .line {
      color: gray;
    }
    #log .fatal {
      font-weight: bold;
      color: #900;
    }
    #memory_wrapper {
      position: relative;
    }
    #memory_window {
      overflow-y: scroll;
      width: 400px;
      height: 304px;
    }
    #memory_stub {
      height: 8480px;
    }
    #memory_view {
      position: relative;
      float: left;
      top: 0px;
      left:0px;
    }
    #memory_lines {
      position: relative;
      float: left;
      top: 0px;
      left: 0px;
      padding-right: 6px;
      color: gray;
    }
    .reg_name {
      padding-left: 20px;
      font-weight: bold;
      color: gray;
    }
    .cur_sp {
      background-color: #aaaaff;
      text-decoration: none;
    }
    .cur_pc {
      background-color: #aaffaa;
      text-decoration: none;
    }
    .line_highlight {
      background-color: #aaffaa;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 19px;
      z-index: -1000;
    }
    .hlight_wrap {
      position: relative;
    }
    #screen {
      background-color: black;
      padding: 4px;
    }
    .notice {
      margin: 6px 0px 10px 0px;
      color: gray;
      font-size: 14px;
    }
    .notice a {
      color: black;
    }
    #tab1_wrapper {
      display: none;
    }
    #da_code .op, #log .op {
      font-weight: bold;
      color: #700;
    }
    #da_code .reg, #log .reg {
      font-weight: bold;
      color: #070;
    }
    #da_code .lit, #log .lit {
      color: #007;
    }
    #da_code .kw, #log .kw {
      color: #077;
    }
    #da_code .lbl, #log .lbl {
      color: #707;
    }
    .tabs {
      margin-bottom: 2px;
    }
    .tab_active {
      background-color: #8AE;
      color: white;
      padding: 2px 7px;
      text-decoration: none;
      border-radius: 4px 4px 0px 0px;
      margin: 0px 5px;
    }
    .tab_inactive {
      background-color: #FFF;
      color: #57C;
      padding: 2px 7px;
      text-decoration: none;
      border-radius: 4px 4px 0px 0px;
      margin: 0px 5px;
    }
    #disassembleDump {
      float: right;
      margin-top: 19px;
    }
    #screen_wrapper {
      position: relative;
    }
    #loading_overlay {
      position: absolute;
      top: 0px;
      left: 0px;
      margin: 4px;
    }
  </style>
</head>
<body>
  <h3>DCPU-16 Assembler, Emulator &amp; Disassembler</h3>
  <div class="notice">by deNULL. Report any problems at <a href="mailto:me@denull.ru">me@denull.ru</a>.</div>

  <table width="100%" border=0 cellpadding=0 cellspacing=0 style="padding-top: 6px"><tr valign=top>
  <td width="80%">
    <div class="tabs"><a href="javascript:" onclick="toggleTab(0)" class="tab_active" id="tab0">Assembler</a><a href="javascript:" onclick="toggleTab(1)" class="tab_inactive" id="tab1">Disassembler</a></div>
    <div id="tab0_wrapper">
    <table width="100%" id="assembler" cellpadding=0 cellspacing=0><tr valign=top>
      <td width="20"><div class="hlight_wrap"><div class="line_highlight" id="hlight1"></div></div><div class="editor" id="linenums"></div></td>
      <td width="60%"><div class="hlight_wrap"><div class="line_highlight" id="hlight2"></div></div><textarea class="editor" id="code" onkeyup="assemble()" onchange="assemble()" wrap=off spellcheck="false" placeholder="Place your code here"><?php
$default_code = <<<EOF
    ; Try some basic stuff
                  SET A, 0x30              ; 7c01 0030
                  SET [0x1000], 0x20       ; 7de1 1000 0020
                  SUB A, [0x1000]          ; 7803 1000
                  IFN A, 0x10              ; c00d
                     SET PC, crash         ; 7dc1 001a [*]

    ; Do a loopy thing
                  SET I, 10                ; a861
                  SET A, 0x2000            ; 7c01 2000
    :loop         SET [0x2000+I], [A]      ; 2161 2000
                  SUB I, 1                 ; 8463
                  IFN I, 0                 ; 806d
                     SET PC, loop          ; 7dc1 000d [*]

    ; Call a subroutine
                  SET X, 0x4               ; 9031
                  JSR testsub              ; 7c10 0018 [*]
                  SET PC, crash            ; 7dc1 001a [*]

    :testsub      SHL X, 4                 ; 9037
                  SET PC, POP              ; 61c1

    ; Hang forever. X should now be 0x40 if everything went right.
    :crash        SET PC, crash            ; 7dc1 001a [*]

    ; [*]: Note that these can be one word shorter and one cycle faster by using the short form (0x00-0x1f) of literals,
    ;      but my assembler doesn't support short form labels yet.
EOF;
$code = $default_code;
if (isset($_REQUEST['code'])) {
  $code = $_REQUEST['code'];
}
echo htmlspecialchars($code);?></textarea>
</td>
      <!--
    ; Assembler test for DCPU
    ; by Markus Persson

    :start
      set i, 0
      set j, 0
      set b, 0xf100
    :nextchar
      set a, [data+i]
      ife a, 0
        set PC, end
      ifg a, 0xff
        set PC, setcolor
      bor a, b
      set [0x8000+j], a
      add i, 1
      add j, 1
      set PC, nextchar

    :setcolor
      set b, a
      and b, 0xff
      shl b, 8
      ifg a, 0x1ff
        add b, 0x80
      add i, 1
      set PC, nextchar


    :data
      dat 0x170, "Hello ", 0x2e1, "world", 0x170, ", how are you?"

    :end
      set PC, start
      -->
      <td width="30"><div class="hlight_wrap"><div class="line_highlight" id="hlight3"></div></div><div class="editor" id="offsets"></div></td>
      <td width="40%"><div class="hlight_wrap"><div class="line_highlight" id="hlight4"></div></div><div class="editor" id="dump"></div></td>
    </tr>
<tr valign=top><td></td><td colspan=3>
<!--<button id="loadsrc" onclick="ge('savesrc_f').click();">Load source...</button>
<button onclick="ge('savesrc_f').click();" id="savesrc">Save source...</button>
<button onclick="ge('savebin_f').click();" id="savebin">Save assembled code...</button>-->
<span class="notice">Click on the line numbers to toggle breakpoints.</span>
</td></tr>
    </table>
    </div>
    <div id="tab1_wrapper">
    <table width="100%" id="disassembler" cellpadding=0 cellspacing=0><tr valign=top>
      <td width="40%"><textarea class="editor" id="da_input" onkeyup="disassemble()" onchange="disassemble()" wrap=off placeholder="Place your hex codes here"></textarea></td>
      <td width="30"><div class="editor" id="da_lines"></div></td>
      <td width="60%"><div class="editor" id="da_code"></div></td>
    </tr>
<tr valign=top><td colspan=3>
<!--<button onclick="loadbin()" id="loadbin">Load binary...</button>
<button onclick="savebin2()" id="savebin2">Save binary...</button>
<button onclick="savedisasm()" id="savedisasm">Save disassembled code...</button>-->
</td></tr>
    </table>
    </div>
  </td>
  <td rowspan=2 width="20%" id="debugger" style="padding-left: 20px">
    <span>Cycles: </span><span id="cycles">0</span><br/>
    <button onclick="run(this)" id="button_run" class="big"/>&#8595; Run (F5)</button><button onclick="step()"  class="big"/>&#8618; Step (F6)</button><button onclick="reset()" class="big">&#8634; Reset</button><br/>
    <label for="show_pc"><input type="checkbox" id="show_pc" name="show_pc" checked="checked" onchange="toggleShowPC()"/> Show current line</label>
    <h4>Screen:</h4>
    <div id="screen_wrapper">
      <canvas id="screen" width="384" height="288"></canvas>
      <img id="loading_overlay" src="http://i.imgur.com/DcNzS.png" width="384" height="288"/>
    </div>
    <div class="notice">Keyboard input is available while the program is running.</div>
    <h4>Registers:</h4>
    <table border=0 class="editor">
    <tr>
      <td class="reg_name">PC:</td><td id="regPC" class="cur_pc">0</td>
      <td class="reg_name">SP:</td><td id="regSP" class="cur_sp">0</td>
      <td class="reg_name">IA:</td><td id="regIA" class="cur_ia">0</td>
    </tr> <tr>
      <td class="reg_name">A:</td><td id="regA">0</td>
      <td class="reg_name">B:</td><td id="regB">0</td>
      <td class="reg_name">C:</td><td id="regC">0</td>
    </tr> <tr>
      <td class="reg_name">X:</td><td id="regX">0</td>
      <td class="reg_name">Y:</td><td id="regY">0</td>
      <td class="reg_name">Z:</td><td id="regZ">0</td>
    </tr> <tr>
      <td class="reg_name">I:</td><td id="regI">0</td>
      <td class="reg_name">J:</td><td id="regJ">0</td>
    </tr> <tr>
      <td class="reg_name">EX:</td><td id="regEX">0</td>
    </tr>
    </table>

    <button onclick="disassembleDump()" id="disassembleDump">Disassemble</button>
    <h4>Memory dump:</h4>
    <div id="memory_wrapper">
      <div id="memory_window" onscroll="updateMemoryView()">
        <div id="memory_stub">
        <div id="memory_lines" class="editor"></div>
        <div id="memory_view" class="editor"></div></div>
      </div>
    </div>
  </td>
  </tr><tr valign=top>
  <td colspan=3>
  <div id="log" class="editor"></div></td>
  </tr></table>
  <script language="javascript">
    var startup = (new Date()).getTime();
    var cycles = 0;
    var memory = [];
    var registers = {A: 0, B: 0, C: 0, X: 0, Y: 0, Z: 0, I: 0, J: 0, PC: 0, SP: 0, EX: 0, IA: 0};
    var memToLine = {};
    var lineToMem = {};
    var breaks = {};

    document.onkeydown = function(event) {
      var code = window.event ? event.keyCode : event.which;
      switch (code) {
        case 116: { // F5
          run(ge("button_run"));
          return false;
        }
        case 117: { // F6
          step();
          return false;
        }
        default: { // pass it to program
          if (!runningTimer) return true;
          return Keyboard.onkeydown(event);
        }
      }
    };
    document.onkeypress = function(event) {
      if (!runningTimer) return true;
      if (event.which == 8) { return false; }

      Keyboard.onkeypress(event);
    };
    document.onkeyup = function(event) {
      if (!runningTimer) return true;
      Keyboard.onkeyup(event);
    };

    function toggleTab(index) {
      for (var i = 0; i < 2; i++) {
        ge("tab" + i + "_wrapper").style.display = (index == i) ? "block" : "none";
        ge("tab" + i).className = (index == i) ? "tab_active" : "tab_inactive";
      }
    }
    function updateRegisters() {
      for (var reg in registers) {
        ge("reg" + reg).innerHTML = pad(parseInt(registers[reg]).toString(16), 4);
      }
      ge("cycles").innerHTML = cycles;
    }
    function toggleShowPC() {
      updateHighlight();
    }
    updateRegisters();

    function updateMemoryView() {
      var lns = "";
      var s = "";
      var offs = ge("memory_window").scrollTop * 8;
      ge("memory_lines").style.top = (offs / 8) + "px";
      ge("memory_view").style.top = (offs / 8) + "px";
      for (var i = 0; i < 16; i++) {
        lns += pad((offs + i * 8).toString(16), 4) + ":<br/>";
        for (var j = 0; j < 8; j++) {
          var v = memory[offs + i * 8 + j];
          if (!v) v = 0;
          v = pad(v.toString(16), 4);
          if (((offs + i * 8 + j + 1) & 0xffff) == registers.SP) {
            s += " <u class='cur_sp'>" + v + "</u>";
          } else
          if (offs + i * 8 + j == registers.PC) {
            s += " <u class='cur_pc'>" + v + "</u>";
          } else {
            s += " " + v;
          }
        }
        s += "<br/>";
      }
      ge("memory_lines").innerHTML = lns;
      ge("memory_view").innerHTML = s;
    }
    updateMemoryView();
    function positionHighlight(line) {
      if (!ge("show_pc").checked) {
        line = -1;
      }
      for (var i = 1; i <= 4; i++) {
        var hlight = ge("hlight" + i);
        if (line >= 0) {
          hlight.style.top = line * 19 + 2;
          hlight.style.display = "block";
        } else {
          hlight.style.display = "none";
        }
      }
    }
    function updateHighlight() {
      positionHighlight(memToLine[registers.PC] - 1);
    }
    positionHighlight(-1);
    function reset() {
      for (var i = 0; i <= 0xffff; i++) {
        if (memory[i]) memory[i] = 0;
      }
      for (var reg in registers) {
        registers[reg] = 0;
      }
      registers.SP = 0;
      cycles = 0;
      keypointer = 0;
      Screen.MAP_SCREEN = 0x8000; // for backward compatability... will be reset to 0 in future
      Screen.MAP_FONT = 0x8180;
      Screen.MAP_PALETTE = 0;
      Screen.BORDER_COLOR = 0;
      Screen.resetFont(memory);
      assemble();
    }
    var logger = function(offset, msg, fatal) {
      //log.push(pad(line + 1, 5) + ": " + (fatal ? "(Fatal) " : "") + msg);
      if (fatal) clearInterval(runningTimer);
    };

    function updateViews(show_all) {
      if (show_all) {
        updateHighlight();
        updateMemoryView();
      }
      updateRegisters();
      Screen.update(memory);
      document.getElementById("cycles").innerHTML = cycles;
    }

    function step() {
      ge('loading_overlay').style.display = 'none';
      var rv = DCPU.step(memory, registers, [ Screen, Keyboard ]);
      if (rv > 0) {
        cycles += rv;
      }
      updateViews(true);
    }

    var runningTimer = false;
    function run(button) {
      ge('loading_overlay').style.display = 'none';
      if (runningTimer) {
        clearInterval(runningTimer);
        runningTimer = false;
        button.innerHTML = "&#8595; Run (F5)";
        updateViews(true);
      } else {
        runningTimer = setInterval(function() {
          var was_cycles = cycles;
          for (var i = 0; i < 10000; i++) {
            var rv = DCPU.step(memory, registers, [ Screen, Keyboard ]);
            if (rv < 0) { // break
              if (runningTimer) run(button);
              return;
            }
            cycles += rv;
            if (!runningTimer) return;
            if (breaks[memToLine[registers.PC] - 1]) {
              run(button);
              return;
            }
            if (cycles > was_cycles + 5213) break;
          }
          updateViews(true);
        }, 50);
        button.innerHTML = "&#215; Stop (F5)";
      }
    }
    function bp(line) {
      breaks[line] = !breaks[line] && (lineToMem[line] !== undefined);
      ge("ln" + line).className = breaks[line] ? "breakpoint" : "";
    }
    function pad(v, w) {
      var s = "" + v;
      var len = s.length;
      for (var i = 0; i < w - len; i++)
        s = "0" + s;
      return s;
    }

    function assemble() {
      var lines = ge("code").value.split("\n");
      var log = [];

      var linenums = [];
      for (var i = 0; i < lines.length; i++) {
        linenums.push("<u id=ln" + i + " onclick='bp(" + i + ")'>" + (i + 1) + "</u>");
      }
      ge("linenums").innerHTML = linenums.join("");

      var logger = function(line, address, pos, message, fatal) {
        log.push("<span class='line'>" + pad(line + 1, 5) + ":</span> " +
          (fatal ? "(<span class='fatal'>Fatal</span>) " : "") +
          message);
        ge("ln" + line).style.backgroundColor = '#f88';
      };
      for (var i = 0; i < 0xffff; i++) {
        if (memory[i]) memory[i] = 0;
      }
      Screen.resetFont(memory);
      var rv = Assembler.compile(lines, memory, logger);

      // map line # to address, and build up offsets/dump
      memToLine = {};
      lineToMem = {};
      var offsets = [];
      var dump = [];
      if (rv) {
        for (var i = 0; i < lines.length; i++) {
          if (rv.infos[i] === undefined || rv.infos[i].size == 0) {
            offsets.push("");
            dump.push("");
          } else {
            var info = rv.infos[i];
            offsets.push(pad(info.pc.toString(16), 4) + ":");
            lineToMem[i] = info.pc;
            var s = "";
            for (var j = 0; j < info.dump.length; j++) {
              s += pad(info.dump[j].toString(16), 4) + " ";
              memToLine[info.pc + j] = i + 1;
            }
            dump.push(s);
          }
        }
      }

      // update UI
      ge("offsets").innerHTML = offsets.join("<br/>");
      ge("dump").innerHTML = dump.join("<br/>");
      ge("log").innerHTML = log.join("<br/>");
      ge("code").style.height = Math.max(560, ((lines.length + 1) * 19 + 9)) + "px";

      for (var line in breaks) {
        if (breaks[line] && (lineToMem[line] === undefined)) {
          bp(line);
        } else
          ge("ln" + line).className = breaks[line] ? "breakpoint" : "";
      }
      updateViews(true);
    }

    function disassemble() {
      var lines = ge("code").value.split("\n");
      var logger = function(line, address, pos, message, fatal) { };
      var buffer = [ ];
      var rv = Assembler.compile(lines, buffer, logger);
      if (!rv) return;

      // figure out where code is being compiled
      var code_blocks = [ ];
      var pc_start = -1;
      var pc_current = -1;
      for (var i = 0; i < rv.infos.length; i++) {
        var info = rv.infos[i];
        if (info === undefined) continue;
        if (info.pc != pc_current) {
          if (pc_current != -1 && pc_current > pc_start) code_blocks.push({ start: pc_start, end: pc_current });
          pc_start = info.pc;
          pc_current = info.pc;
        }
        pc_current += (info.size || 0);
      }
      if (pc_current != -1 && pc_current > pc_start) code_blocks.push({ start: pc_start, end: pc_current });

      var targets = [ ];
      for (var i = 0; i < code_blocks.length; i++) {
        var t = Disassembler.findTargets(buffer, code_blocks[i].start, code_blocks[i].end);
        targets = targets.concat(t);
      }
      targets.sort();
      var labels = { };
      for (var i = 0; i < targets.length; i++) {
        labels[targets[i]] = "label" + i;
      }

      var lines = [];
      var output = [];
      var conditional = false;
      for (var i = 0; i < code_blocks.length; i++) {
        var pc = code_blocks[i].start;
        var end = code_blocks[i].end;
        do {
          var info = Disassembler.disassemble(buffer, pc, labels, function(type, str) {
            return "<span class='" + type + "'>" + str + "</span>";
          });
          if (labels[pc]) {
            lines.push("");
            output.push(":" + wrapAs(labels[pc], "lbl"));
          }
          if (info.code !== undefined) {
            lines.push(pad(pc.toString(16), 4) + ":");
            output.push("&nbsp;&nbsp;" + (conditional ? "&nbsp;&nbsp;" : "") + info.code);
          }
          pc += info.size;
          conditional = info.conditional;
        } while (pc < end);
        lines.push("");
        output.push("");
      }

      // update UI
      ge("da_lines").innerHTML = lines.join("<br/>");
      ge("da_code").innerHTML = output.join("<br/>");
      ge("da_input").style.height = Math.max(560, ((lines.length + 1) * 19 + 9)) + "px";
    }

    function disassembleDump() {
      var dump = "";
      var end = 0x7ffe;
      while (!memory[end] && end > 0) end--;
      for (var i = 0; i <= end + 1; i++) {
        dump += pad((memory[i] || 0).toString(16), 4);
        dump += (i % 8 == 7) ? "\n" : " ";
      }
      ge("da_input").value = dump;
      disassemble();
      toggleTab(1);
    }

    Screen.init();
    Keyboard.init();
    disassemble();
    reset();
    var lastCode = ge("code").value;
    var lastInput = ge("da_input").value;

    setInterval(function() {
      Screen.blink = !Screen.blink;
      Screen.update(memory);

      var code = ge("code").value;
      if (code != lastCode) {
        lastCode = code;
        assemble();
      }
      var input = ge("code").value;
      if (input != lastInput) {
        lastInput = input;
        //disassemble();
      }
    }, 600);
  </script>
</body>
</html>